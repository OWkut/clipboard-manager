["restoreFocus(previousWindowID)","time.Sleep(100 * time.Millisecond)","func restoreFocus(windowID string) {\n\tif windowID == \"\" {\n\t\tlog.Println(\"ID de la fenêtre non valide.\")\n\t\treturn\n\t}\n\tcmd := exec.Command(\"xdotool\", \"windowactivate\", windowID)\n\terr := cmd.Run()\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors du retour du focus :\", err)\n\t}\n}","kb.HasCTRL(true)","\tkb.HasCTRL(true) // Maintenir Ctrl","package main\n\nimport (\n\t\"encoding/json\"\n\t\"log\"\n\t\"os\"\n\t\"os/exec\"\n\t\"strconv\"\n\t\"time\"\n\n\t\"fyne.io/fyne/v2\"\n\t\"fyne.io/fyne/v2/app\"\n\t\"fyne.io/fyne/v2/container\"\n\t\"fyne.io/fyne/v2/widget\"\n\t\"github.com/atotto/clipboard\"\n\t\"github.com/micmonay/keybd_event\"\n)\n\nconst historyFile = \"clipboard_history.json\"\n\nfunc getActiveWindowID() string {\n\tcmd := exec.Command(\"xdotool\", \"getactivewindow\")\n\toutput, err := cmd.Output()\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors de l'obtention de la fenêtre active :\", err)\n\t\treturn \"\"\n\t}\n\treturn string(output)\n}\n\nfunc restoreFocus(windowID string) {\n\tif windowID == \"\" {\n\t\tlog.Println(\"ID de la fenêtre non valide.\")\n\t\treturn\n\t}\n\tcmd := exec.Command(\"xdotool\", \"windowactivate\", windowID)\n\terr := cmd.Run()\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors du retour du focus :\", err)\n\t}\n}\n\nfunc pasteClipboard() {\n\tkb, err := keybd_event.NewKeyBonding()\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors de la création du simulateur de clavier :\", err)\n\t\treturn\n\t}\n\n\t// Définir les touches (29 = Ctrl, 47 = V)\n\tkb.HasCTRL(true) // Maintenir Ctrl\n\tkb.SetKeys(47)   // Touche V\n\n\t// Simuler Ctrl + V\n\terr = kb.Launching()\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors de la simulation du collage :\", err)\n\t}\n\n\t// Pause légère pour éviter des doublons\n\ttime.Sleep(50 * time.Millisecond)\n}\n\nfunc main() {\n\tmyApp := app.New()\n\tmyWindow := myApp.NewWindow(\"Gestionnaire de Presse-papiers\")\n\tvar selectedRow int = -1\n\tmyWindow.SetMaster()\n\n\thistory := loadHistory()\n\n\t// Créer un widget.Table pour afficher l'historique\n\ttable := widget.NewTable(\n\t\tfunc() (int, int) {\n\t\t\treturn len(history), 2 // 2 colonnes : index et texte\n\t\t},\n\t\tfunc() fyne.CanvasObject {\n\t\t\treturn widget.NewLabel(\"\")\n\t\t},\n\t\tfunc(i widget.TableCellID, o fyne.CanvasObject) {\n\t\t\tif i.Col == 0 {\n\t\t\t\to.(*widget.Label).SetText(strconv.Itoa(i.Row + 1)) // Afficher l'index\n\t\t\t} else {\n\t\t\t\to.(*widget.Label).SetText(history[len(history)-1-i.Row]) // Afficher le texte\n\t\t\t}\n\t\t},\n\t)\n\n\tpreviousWindowID := getActiveWindowID()\n\n\t// Gérer la sélection dans le tableau\n\ttable.OnSelected = func(id widget.TableCellID) {\n\t\tif id.Row \u003e= 0 \u0026\u0026 id.Row \u003c len(history) {\n\t\t\ttext := history[len(history)-1-id.Row]\n\t\t\terr := clipboard.WriteAll(text)\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Erreur lors de la copie dans le presse-papiers :\", err)\n\t\t\t}\n\n\t\t\tmyWindow.Hide()\n\t\t\trestoreFocus(previousWindowID) // Force le retour du focus\n\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\tpasteClipboard()\n\t\t}\n\t}\n\n\t// Bouton pour effacer l'historique\n\tclearButton := widget.NewButton(\"Effacer l'historique\", func() {\n\t\thistory = []string{}          // Vider l'historique en mémoire\n\t\terr := os.Remove(historyFile) // Supprimer le fichier d'historique\n\t\tif err != nil {\n\t\t\tlog.Println(\"Erreur lors de la suppression du fichier d'historique :\", err)\n\t\t}\n\t\ttable.Refresh()\n\t})\n\n\t// Bouton pour coller la sélection\n\tpasteButton := widget.NewButton(\"Coller la sélection\", func() {\n\t\tif selectedRow \u003e= 0 \u0026\u0026 selectedRow \u003c len(history) {\n\t\t\ttext := history[len(history)-1-selectedRow]\n\t\t\terr := clipboard.WriteAll(text)\n\t\t\tselectedRow = -1\n\t\t\ttable.UnselectAll()\n\t\t\tif err != nil {\n\t\t\t\tlog.Println(\"Erreur lors de la copie dans le presse-papiers :\", err)\n\t\t\t}\n\t\t} else {\n\t\t\tlog.Println(\"Aucune ligne sélectionnée.\")\n\t\t}\n\t})\n\n\t// Mettre à jour l'historique en temps réel\n\tgo func() {\n\t\tlastText := \"\"\n\t\tfor {\n\t\t\ttext, err := clipboard.ReadAll()\n\t\t\tif err == nil \u0026\u0026 text != lastText {\n\t\t\t\tlastText = text\n\t\t\t\thistory = append(history, text)\n\t\t\t\tif len(history) \u003e 20 { // Limiter l'historique à 20 éléments\n\t\t\t\t\thistory = history[1:]\n\t\t\t\t}\n\t\t\t\tsaveHistory(history)\n\t\t\t\ttable.Refresh()\n\t\t\t}\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t}\n\t}()\n\n\t// Organiser l'interface avec un conteneur Border\n\tmyWindow.SetContent(container.NewBorder(\n\t\twidget.NewLabel(\"Historique du presse-papiers :\"), // En haut\n\t\tcontainer.NewHBox(clearButton, pasteButton),       // En bas\n\t\tnil,                        // À gauche (rien)\n\t\tnil,                        // À droite (rien)\n\t\tcontainer.NewScroll(table), // Au centre (avec scrollbar)\n\t))\n\n\tmyWindow.Resize(fyne.NewSize(600, 400)) // Ajustez la taille selon vos besoins\n\tmyWindow.ShowAndRun()\n}\n\nfunc loadHistory() []string {\n\tif _, err := os.Stat(historyFile); os.IsNotExist(err) {\n\t\treturn []string{}\n\t}\n\n\tdata, err := os.ReadFile(historyFile)\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors de la lecture du fichier d'historique :\", err)\n\t\treturn []string{}\n\t}\n\n\tvar history []string\n\tif err := json.Unmarshal(data, \u0026history); err != nil {\n\t\tlog.Println(\"Erreur lors de la désérialisation de l'historique :\", err)\n\t\treturn []string{}\n\t}\n\n\treturn history\n}\n\nfunc saveHistory(history []string) {\n\tdata, err := json.Marshal(history)\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors de la sérialisation de l'historique :\", err)\n\t\treturn\n\t}\n\n\tif err := os.WriteFile(historyFile, data, 0644); err != nil {\n\t\tlog.Println(\"Erreur lors de l'écriture du fichier d'historique :\", err)\n\t}\n}\n","kb.HasCTRL(true)\nkb.SetKeys(keybd_event.VK_V)\n\nerr = kb.Launching()\nif err != nil {\n\tlog.Println(\"Erreur lors de la simulation du collage :\", err)\n}\n\nkb.HasCTRL(false) // Relâchement de la touche Ctrl après le collage\n","time.Sleep(300 * time.Millisecond)","func pasteClipboard() {\n\tcmd := exec.Command(\"xdotool\", \"key\", \"ctrl+v\")\n\terr := cmd.Run()\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors de la simulation du collage avec xdotool :\", err)\n\t}\n}\n","var internalCopy = false\n","err := clipboard.WriteAll(text)\nif err != nil {\n\tlog.Println(\"Erreur lors de la copie dans le presse-papiers :\", err)\n} else {\n\tinternalCopy = true // Indiquer que c'est un copier interne\n}\n","go func() {\n\tlastText := \"\"\n\tfor {\n\t\ttext, err := clipboard.ReadAll()\n\t\tif err == nil \u0026\u0026 text != lastText {\n\t\t\tlastText = text\n\n\t\t\tif internalCopy {\n\t\t\t\tinternalCopy = false // Réinitialiser le flag\n\t\t\t} else {\n\t\t\t\thistory = append(history, text)\n\t\t\t\tif len(history) \u003e 20 { // Limiter l'historique à 20 éléments\n\t\t\t\t\thistory = history[1:]\n\t\t\t\t}\n\t\t\t\tsaveHistory(history)\n\t\t\t\ttable.Refresh()\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}()\n","base","go func() {\n\tlastText := \"\"\n\tfor {\n\t\ttext, err := clipboard.ReadAll()\n\t\tif err == nil \u0026\u0026 text != lastText {\n\t\t\tlastText = text\n\n\t\t\t// Vérifie si le texte est déjà dans l'historique\n\t\t\tif len(history) == 0 || history[len(history)-1] != text {\n\t\t\t\thistory = append(history, text)\n\t\t\t\tif len(history) \u003e 20 { // Limiter l'historique à 20 éléments\n\t\t\t\t\thistory = history[1:]\n\t\t\t\t}\n\t\t\t\tsaveHistory(history)\n\t\t\t\ttable.Refresh()\n\t\t\t}\n\t\t}\n\t\ttime.Sleep(500 * time.Millisecond)\n\t}\n}()\n","func removeDuplicates(history []string) []string {\n\tunique := make(map[string]bool)\n\tresult := []string{}\n\n\tfor _, item := range history {\n\t\tif !unique[item] {\n\t\t\tunique[item] = true\n\t\t\tresult = append(result, item)\n\t\t}\n\t}\n\treturn result\n}","history = removeDuplicates(history)","","func loadHistory() []string {\n\tif _, err := os.Stat(historyFile); os.IsNotExist(err) {\n\t\treturn []string{}\n\t}\n\n\tdata, err := os.ReadFile(historyFile)\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors de la lecture du fichier d'historique :\", err)\n\t\treturn []string{}\n\t}\n\n\tvar history []string\n\tif err := json.Unmarshal(data, \u0026history); err != nil {\n\t\tlog.Println(\"Erreur lors de la désérialisation de l'historique :\", err)\n\t\treturn []string{}\n\t}\n\n\treturn history\n}\n\nfunc saveHistory(history []string) {\n\tif len(history) == 0 {\n\t\t// Si l'historique est vide, supprimer le fichier\n\t\terr := os.Remove(historyFile)\n\t\tif err != nil \u0026\u0026 !os.IsNotExist(err) {\n\t\t\tlog.Println(\"Erreur lors de la suppression du fichier d'historique :\", err)\n\t\t}\n\t\treturn\n\t}\n\n\tdata, err := json.Marshal(history)\n\tif err != nil {\n\t\tlog.Println(\"Erreur lors de la sérialisation de l'historique :\", err)\n\t\treturn\n\t}\n\n\tif err := os.WriteFile(historyFile, data, 0644); err != nil {\n\t\tlog.Println(\"Erreur lors de l'écriture du fichier d'historique :\", err)\n\t}\n}","base","https://github.com/Genesis-Embodied-AI/Genesis"]